## 1. 相交链表

### Sol1: Hash遍历

### Sol2: 双指针交换法
——重点查null的返回方式  
——交换意味着要么同时返回相交Node要么同时返回null  
——最后返回Node  

## 2.反转链表

### Sol1: 迭代法
——三个指针  
——cur不停往前走获取链表指针  
——修改cur.next指向前继节点，前继节点用pre保存，也是结果返回   
——此时cur往前走发现没有后继节点指针， 所以在修改cur.next之前， 需要用nextTemp保存cur.next  


## 3.回文链表
### Sol1: 快慢指针+反转后半链表+比较
——快慢指针找到中点  
——反转后半链表  
——比较前半链表和后半链表  
——可选：恢复链表  

### Sol2: 复制到数组后双指针比较
——复制到数组  
——双指针比较  

## 4.合并两个有序链表
### Sol1: 迭代法
——创建哨兵节点，为了保存结果，因为两个有序链表不知道谁会变成头节点  
——用cur指针不停往前走，比较两个链表节点值， 小的接到cur后面  
——最后接上剩余节点  

## 5.两数相加
### Sol1: 迭代法
——创建哨兵节点，为了保存结果  
——创造前景节点**为了保存结果**  
——创造**进位变量**  
——循环条件是l1不为空或者l2不为空  
——每次取l1和l2的节点值，如果为空则取0  
——计算sum = val1 + val2 + carry  
——更新carry = sum /10  
——创建新节点，值为sum %10  
——**循环结束，检查carry是否为1**  
——最后返回哨兵节点的下一个节点  

## 6.删除链表的倒数第N个节点
### Sol1: 双指针法
——创建哨兵节点，为了保存结果  
——创建两个指针，first和second，初始都指向哨兵节点  
——先让**first指针往前走n+1步**  
——然后让first和second指针同时往前走，直到first指针到达链表末尾
——此时second指针指向倒数第n个节点的前一个节点
——**修改second.next指向second.next.next，删除倒数第n个节点**
——最后返回哨兵节点的下一个节点

### Sol2: 计算链表长度法
——创建哨兵节点，为了保存结果  
——计算链表长度len  
——计算要删除节点的位置pos = len - n  
——创建cur指针，初始指向哨兵节点  
——让cur指针往前走pos步  
——修改cur.next指向cur.next.next，删除倒数第n个节点  
——最后返回哨兵节点的下一个节点  

## 7.两两交换链表中的节点
### Sol1: 迭代法
——创建哨兵节点，为了保存结果  
——创建pre指针，初始指向哨兵节点  
——循环条件是pre.next和pre.next.next不为空  
——创建first和second指针，分别指向pre.next和pre.next.next  
——**交换first和second节点**  
——first.next指向second.next(第三节点)  
——second.next指向first  
——**更新pre指针，指向pre.next.next**  
——最后返回哨兵节点的下一个节点  

## 8.环形链表
### Sol1: 快慢指针法
——创建两个指针，slow和fast，初始都指向链表头节点  
——循环条件是fast和fast.next不为空  
——slow指针每次往前走一步，fast指针每次往前走  
——如果slow和fast指针相遇，说明链表有环，返回true  
——如果循环结束，说明链表没有环，返回false  

### Sol2: 哈希表法
——创建一个哈希表，用于存储访问过的节点  
——创建cur指针，初始指向链表头节点  
——循环条件是cur不为空  
——如果cur节点已经在哈希表中，说明链表有环，返回true  
——否则，将cur节点加入哈希表  
——cur指针往前走一步  
——如果循环结束，说明链表没有环，返回false  
——最后返回哨兵节点的下一个节点  

## 9.环形链表 II
### Sol1: 快慢指针法
——创建两个指针，slow和fast，初始都指向链表头节点  
——循环条件是fast和fast.next不为空  
——slow指针每次往前走一步，fast指针每次往前走  
——如果slow和fast指针相遇，说明链表有环，跳出循环  
——如果循环结束，说明链表没有环，返回null  
——循环结束时创建一个指针ptr，初始指向链表头节点  
——循环条件是ptr不等于slow  
——ptr和slow指针每次都往前走一步  
——当ptr和slow指针相遇时，返回相遇节点，即环的入口节点  

## 10.随机链表的复制
### Sol1: 哈希表法
——创建一个哈希表，用于存储原节点和新节点的映射关系  
——若头节点 head 为空节点，直接返回 null   
——初始化： 哈希表 dic ， 节点 cur 指向头节点  
——第一遍遍历： 复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射  
——第二遍遍历： 构建新节点的 next 和 random 指向  
——以当前节点 cur 为例：  
—— 新节点 dic[cur] 的 next 指向 dic[cur.next]  
—— 新节点 dic[cur] 的 random 指向 dic[cur.random]  
——返回新节点 dic[head] 作为新链表的头节点  

### Sol2: 拼接法
——复制各节点，构建拼接链表：设原链表为 node1→node2→⋯ ，构建的拼接链表如下所示：
node1→node1 new →node2→node2new  
——设置新节点的 random 指向
对于原链表中的节点 nodei ， 其对应的新节点 
nodei new 的 random 指针应指向 nodei.random.next
**重点在于，每一个cur.random后面紧跟着的就是对应的random的新节点**  
——拆分链表，得到最终的结果链表和原链表  
——拆分原 / 新链表：设置 pre / cur 分别指向原 / 新链表头节点，遍历执行 pre.next = pre.next.next 和 cur.next = cur.next.next 将两链表拆分开






