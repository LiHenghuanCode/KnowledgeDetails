## 1. 相交链表

### Sol1: Hash遍历

### Sol2: 双指针交换法
——重点查null的返回方式  
——交换意味着要么同时返回相交Node要么同时返回null  
——最后返回Node  

## 2.反转链表

### Sol1: 迭代法
——三个指针  
——cur不停往前走获取链表指针  
——修改cur.next指向前继节点，前继节点用pre保存，也是结果返回   
——此时cur往前走发现没有后继节点指针， 所以在修改cur.next之前， 需要用nextTemp保存cur.next  


## 3.回文链表
### Sol1: 快慢指针+反转后半链表+比较
——快慢指针找到中点  
——反转后半链表  
——比较前半链表和后半链表  
——可选：恢复链表  

### Sol2: 复制到数组后双指针比较
——复制到数组  
——双指针比较  

## 4.合并两个有序链表
### Sol1: 迭代法
——创建哨兵节点，为了保存结果，因为两个有序链表不知道谁会变成头节点  
——用cur指针不停往前走，比较两个链表节点值， 小的接到cur后面  
——最后接上剩余节点  

## 5.两数相加
### Sol1: 迭代法
——创建哨兵节点，为了保存结果  
——创造前景节点**为了保存结果**  
——创造**进位变量**  
——循环条件是l1不为空或者l2不为空  
——每次取l1和l2的节点值，如果为空则取0  
——计算sum = val1 + val2 + carry  
——更新carry = sum /10  
——创建新节点，值为sum %10  
——**循环结束，检查carry是否为1**  
——最后返回哨兵节点的下一个节点  

## 6.删除链表的倒数第N个节点
### Sol1: 双指针法
——创建哨兵节点，为了保存结果  
——创建两个指针，first和second，初始都指向哨兵节点  
——先让**first指针往前走n+1步**  
——然后让first和second指针同时往前走，直到first指针到达链表末尾
——此时second指针指向倒数第n个节点的前一个节点
——**修改second.next指向second.next.next，删除倒数第n个节点**
——最后返回哨兵节点的下一个节点

### Sol2: 计算链表长度法
——创建哨兵节点，为了保存结果  
——计算链表长度len  
——计算要删除节点的位置pos = len - n  
——创建cur指针，初始指向哨兵节点  
——让cur指针往前走pos步  
——修改cur.next指向cur.next.next，删除倒数第n个节点  
——最后返回哨兵节点的下一个节点  
