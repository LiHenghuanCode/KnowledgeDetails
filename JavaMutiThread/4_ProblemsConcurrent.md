# 并发编程的三大问题以及解决方案
无论在在计算机架构的哪一层工作，只要谈到并发，必然有这三大问题：
原子性问题、可见性问题和有序性问题

总之，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。
只要有一个没有得到保证，就有可能会导致程序运行不正确。

## 一、三大问题
### 原子性问题
所谓原子操作，就是“不可中断的一个或一系列操作”，是指不会被线程调度机制打断的操作。
这种操作一旦开始，就一直运行到结束，中间不会有任何线程的切换。

javap是JDK提供的一个命令行工具，能对给定的class文件提供的字节代码进行反编译。通过它可以对照源代码和字节码，从而了解很多编译器内部的工作，
对更深入地理解如何提高程序执行的效率等问题有极大的帮助。命令选项-c表示对代码进行反汇编。

使用javap命令解析出sum++的汇编代码：
```
Code:
            0: aload_0
            1: dup
            2: getfield      #2     // Field sum:I    ①
            5: iconst_1                                  ②
            6: iadd                                       ③
            7: putfield      #2     // Field sum:I    ④
           10: return
```
4个关键性的汇编指令：

① 获取当前sum变量的值，并且放入栈顶。

② 将常量1放入栈顶。

③ 将当前栈顶中的两个值（sum的值和1）相加，并把结果放入栈顶。

④ 把栈顶的结果再赋值给sum变量。

通过以上4个关键性的汇编指令可以看出，在汇编代码的层面，++操作实质上是4个操作。这4个操作之间是可以发生线程切换的，
或者说是可以被其他线程中断的。所以，++操作不是原子操作，在并行场景会发生原子性问题。

### 可见性问题
一个线程对共享变量的修改，另一个线程能够立刻可见，我们称该共享变量具备内存可见性。
谈到内存可见性，要先引出JMM（Java Memory Model，Java内存模型）的概念

JMM规定，将所有的变量都存放在公共主存中，
当线程使用变量时会把主存中的变量复制到自己的工作空间（或者叫私有内存）中，
线程对变量的读写操作，是自己工作内存中的变量副本。
举一个例子：

（1）主存中有变量sum，初始值为0。

（2）线程A计划将sum加1，先将sum=0复制到自己的私有内存中，然后更新sum的值。
线程A操作完成之后其私有内存中sum的值为1，然而线程A将更新后的sum值回刷到主存的时间是不固定的。

（3）在线程A没有回刷sum到主存前，刚好线程B同样从主存中读取sum，
此时值为0，和线程A进行同样的操作，最后期盼的sum=2目标没有达成，最终sum=1。

注意Java局部变量、方法参数不存在内存可见性问题。
在Java中，所有的局部变量、方法定义参数都不会在线程之间共享，所以也就不会有内存可见性问题。

所有的Object实例、 Class实例和数组元素都存储在JVM堆内存中，
堆内存在线程之间共享，所以存在可见性问题

### 有序性问题
所谓程序的有序性，是指程序按照代码的先后顺序执行。
在并发环境下，代码的执行顺序看起来可能和你写的顺序不一样，导致逻辑错误

原因有两类：

**编译器优化**（JIT/编译器会重排指令，只要单线程结果一致就行）

**CPU 执行优化**（CPU 的乱序执行、缓存优化）

## 二、在并发编程之前的底层

### 1.多核CPU的缓存以及MESI 协议


#### 总线锁
在早期多核处理器里，CPU 与内存之间的通信都依赖 前端总线 (Front Side Bus, FSB)。
当某个核心要执行一条涉及共享内存的原子操作时（例如 i++），它会在总线上发出一个特殊的信号 LOCK#：

这个信号会 锁住整个总线，在锁释放之前，其他 CPU **都不能通过总线访问内存**。

等待中的 CPU 必须阻塞，直到总线锁释放

#### 缓存锁
相比总线锁，缓存锁降低了锁的粒度。
在多核处理器中，每个核心都有自己的高速缓存，用来存放**主存中部分数据的副本**。
这样做的好处是加快访问速度，但随之而来的一致性问题是：
当某个核心修改了缓存中的数据，如何保证其他核心在访问该数据时不会读到过期值？

**为了解决不同核心缓存副本可能不一致的问题，主流处理器采用 MESI 协议**：

M (Modified)：缓存行已修改，与主存不一致，只有本核心持有这份数据。

E (Exclusive)：缓存行与主存一致，并且只有本核心持有。

S (Shared)：缓存行与主存一致，但可能存在于多个核心缓存中。

I (Invalid)：缓存行无效，不能使用。

#### MESI的切换




### 2. JMM内存模型

#### 内存屏障与实现有序性的As-if-Serial规则



#### JMM模型


#### Happens-Before规则

## 三、volatile 到底发生了什么
在正常情况下，系统操作并不会校验共享变量的缓存一致性，
只有当共享变量用volatile关键字修饰了，该变量所在的缓存行才被要求进行缓存一致性的校验。
在 Java 内存模型中，volatile 关键字正是为了解决这个问题：

当一个线程写入 volatile 变量时，JVM 会在底层插入带有 lock 前缀的汇编指令。

该指令会触发 CPU 的缓存一致性机制：把修改过的缓存行刷新到主存，并通知其他核心将各自缓存中的这份数据标记为失效。

下次其他核心访问时，就必须重新从主存中获取最新值

volatile关键字对应的汇编指令

在汇编指令中，volatile会使得变量一个lock前缀指令lock addl，该lock前缀指令有三个功能
新版CPU（如IA-32、Intel 64）通过缓存锁实现对共享内存的独占性访问，
（1）将当前CPU缓存行的数据立即写回系统内存
缓存锁（缓存一致性协议）会阻止两个CPU同时修改共享内存的数据。

（2）lock前缀指令会引起在其他CPU中缓存了该内存地址的数据无效

（3）lock前缀指令禁止指令重排，作为内存屏障（Memory Barrier）

